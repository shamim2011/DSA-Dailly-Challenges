// Approach name 1- Brute-Force
// T.C - O(n^3)
// S.C - O(1)

class Solution {
    public int triangleNumber(int[] nums) {
        int count = 0;  // To store the number of valid triangles
        int max = 0;    // To store the largest side in a triplet

        // Loop over all possible triplets (i, j, k)
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                for (int k = j + 1; k < nums.length; k++) {
                    // Get the three sides of the current triplet
                    int a = nums[i];
                    int b = nums[j];
                    int c = nums[k];

                    // Find the largest side among a, b, c
                    max = Math.max(a, Math.max(b, c));

                    // Sum of the other two sides
                    int sum = a + b + c - max;

                    // Check the triangle inequality:
                    // sum of the two smaller sides must be greater than the largest side
                    if (sum > max) {
                        count++;  // Valid triangle found, increment count
                    }
                }
            }
        }

        // Return total number of valid triangles
        return count;
    }
}



// Approach name 2 - Sorting + Two-Pointer Approach
// T.C - O(n^2)
// S.C - O(1)

import java.util.Arrays;

class Solution {
    public int triangleNumber(int[] nums) {
        // Step 1: Sort the array
        // Sorting ensures that for any triplet (i, j, k) with i < j < k,
        // nums[i] <= nums[j] <= nums[k]
        Arrays.sort(nums);

        int n = nums.length;
        int count = 0;  // To store the number of valid triangles

        // Step 2: Fix the largest side of the triangle as nums[k]
        // Iterate k from n-1 down to 2 (since we need at least 3 numbers)
        for (int k = n - 1; k >= 2; k--) {
            int i = 0;       // Start pointer
            int j = k - 1;   // End pointer (just before k)

            // Step 3: Use two-pointer technique to find valid pairs (i, j)
            while (i < j) {
                // If nums[i] + nums[j] > nums[k], it forms a triangle
                if (nums[i] + nums[j] > nums[k]) {
                    // All pairs from i to j-1 with j will also satisfy the triangle inequality
                    count += (j - i);

                    // Move the end pointer left to check next possible pair
                    j--;
                } else {
                    // If the sum is not greater than nums[k], move start pointer right
                    i++;
                }
            }
        }

        // Step 4: Return the total count of valid triangles
        return count;
    }
}



//Approach-3 (Binary Search)
//T.C : O(n^2 * logn)
//S.C : O(1)

class Solution {
    public int triangleNumber(int[] nums) {
        // Step 1: Sort the array so that we can apply the triangle property easily
        Arrays.sort(nums);

        int n = nums.length;
        if (n < 3) return 0;   // If less than 3 sides, no triangle possible

        int count = 0;  // To store the total number of valid triangles

        // Step 2: Fix the first side nums[i]
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) continue;  // Zero-length side cannot form a triangle

            // Step 3: Fix the second side nums[j] (always greater than i)
            for (int j = i + 1; j < n; j++) {
                int sum = nums[i] + nums[j];  // Sum of the two chosen sides

                // Step 4: Use binary search to find the largest index 'k'
                // such that nums[k] < nums[i] + nums[j]
                int k = binarySearch(nums, j + 1, n - 1, sum);

                // If a valid 'k' is found, then all elements from (j+1) to k
                // can form valid triangles with nums[i] and nums[j]
                if (k != -1) {
                    count += (k - j);  // Add number of valid choices for the 3rd side
                }
            }
        }
        return count;
    }

    // Custom binary search function
    // Finds the rightmost index 'k' such that nums[k] < target
    int binarySearch(int[] nums, int l, int r, int target) {
        int k = -1;  // Default value when no valid index is found

        while (l <= r) {
            int mid = (l + r) / 2;

            if (nums[mid] < target) {
                k = mid;       // nums[mid] is valid, but try to find a larger one
                l = mid + 1;   // Move right
            } else {
                r = mid - 1;   // Too large, move left
            }
        }
        return k;
    }
}
