// Approach 1 - Array Conversion + Two Pointer Approach
// T.C - O(n)
// S.C - O(n)


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int pairSum(ListNode head){
        
        // List to store all node values
        List<Integer> li = new ArrayList<>();
        
        // Traverse the linked list and store values in the list
        while(head != null){
            li.add(head.val);
            head = head.next;
        }
        
        // Two pointers: start and end of the list
        int i = 0;
        int j = li.size() - 1;
        
        // To store the maximum twin sum
        int ans = Integer.MIN_VALUE;
        
        // Calculate twin sums using two-pointer approach
        while(i < j){
            ans = Math.max(ans, li.get(i) + li.get(j));
            i++;
            j--;
        }
        
        // Return the maximum twin sum
        return ans;
    }
}



// Approach 2 - Stack-Based Twin Sum Approach
// T.C - O(n)
// S.C - O(n)



class Solution {
    public int pairSum(ListNode head){

        // Stack to store all node values
        Stack<Integer> st = new Stack<>();

        // Temporary pointer to traverse the linked list
        ListNode temp = head;

        // Push all node values into the stack
        while(temp != null){
            st.push(temp.val);
            temp = temp.next;
        }

        // Total number of nodes
        int size = st.size();

        // Stores maximum twin sum
        int ans = Integer.MIN_VALUE;

        // Counter to process only first half of the list
        int count = 1;

        // Reset temp to head for second traversal
        temp = head;

        // Calculate twin sums for first half of nodes
        while(count <= size / 2){
            ans = Math.max(ans, temp.val + st.pop());
            temp = temp.next;
            count++;
        }

        // Return maximum twin sum
        return ans;
    }
}


// Approach 3 - Two Pointer + Reverse Second Half
// T.C - O(n)
// S.C - O(1)


class Solution {
    public int pairSum(ListNode head){

        // Step 1: Find the middle of the linked list
        ListNode slow = head;
        ListNode fast = head;

        // Slow moves 1 step, fast moves 2 steps
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        // 'slow' is now at the middle of the list
        ListNode mid = slow;

        // Step 2: Reverse the second half of the linked list
        ListNode prev = null;
        ListNode nextNode = null;

        while(mid != null){
            nextNode = mid.next;  // store next node
            mid.next = prev;      // reverse the link
            prev = mid;           // move prev forward
            mid = nextNode;       // move mid forward
        }

        // Step 3: Calculate maximum twin sum
        int ans = 0;
        ListNode curr = head;

        // Compare first half and reversed second half
        while(prev != null){
            ans = Math.max(ans, curr.val + prev.val);
            curr = curr.next;
            prev = prev.next;
        }

        return ans;
    }
}
