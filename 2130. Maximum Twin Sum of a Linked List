// Approach 1 - Array Conversion + Two Pointer Approach
// T.C - O(n)
// S.C - O(n)


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int pairSum(ListNode head){
        
        // List to store all node values
        List<Integer> li = new ArrayList<>();
        
        // Traverse the linked list and store values in the list
        while(head != null){
            li.add(head.val);
            head = head.next;
        }
        
        // Two pointers: start and end of the list
        int i = 0;
        int j = li.size() - 1;
        
        // To store the maximum twin sum
        int ans = Integer.MIN_VALUE;
        
        // Calculate twin sums using two-pointer approach
        while(i < j){
            ans = Math.max(ans, li.get(i) + li.get(j));
            i++;
            j--;
        }
        
        // Return the maximum twin sum
        return ans;
    }
}



// Approach 2 - Stack-Based Twin Sum Approach
// T.C - O(n)
// S.C - O(n)



class Solution {
    public int pairSum(ListNode head){

        // Stack to store all node values
        Stack<Integer> st = new Stack<>();

        // Temporary pointer to traverse the linked list
        ListNode temp = head;

        // Push all node values into the stack
        while(temp != null){
            st.push(temp.val);
            temp = temp.next;
        }

        // Total number of nodes
        int size = st.size();

        // Stores maximum twin sum
        int ans = Integer.MIN_VALUE;

        // Counter to process only first half of the list
        int count = 1;

        // Reset temp to head for second traversal
        temp = head;

        // Calculate twin sums for first half of nodes
        while(count <= size / 2){
            ans = Math.max(ans, temp.val + st.pop());
            temp = temp.next;
            count++;
        }

        // Return maximum twin sum
        return ans;
    }
}

