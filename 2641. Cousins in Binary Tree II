//Approach 1 - Level Order Traversal (BFS) with Level Sum Precomputation
//T.C : O(n)
//S.C : O(n)


class Solution {
    public TreeNode replaceValueInTree(TreeNode root) {

        // Edge case
        if (root == null) return root;

        Queue<TreeNode> q = new LinkedList<>();
        List<Integer> levelSum = new ArrayList<>();

        // -------------------------------
        // 1️⃣ BFS to calculate level sums
        // -------------------------------
        q.offer(root);

        while (!q.isEmpty()) {
            int n = q.size();   // number of nodes at current level
            int sum = 0;

            while (n-- > 0) {
                TreeNode curr = q.poll();
                sum += curr.val;  // add node value to level sum

                if (curr.left != null) q.offer(curr.left);
                if (curr.right != null) q.offer(curr.right);
            }
            // store sum of current level
            levelSum.add(sum);
        }

        // ----------------------------------------
        // 2️⃣ BFS again to update node values
        // ----------------------------------------
        q.offer(root);

        root.val = 0;   // root has no cousins
        int i = 1;      // index for next level sum

        while (!q.isEmpty()) {
            int n = q.size();  // nodes at current level

            while (n-- > 0) {
                TreeNode curr = q.poll();

                // Calculate sibling sum (left + right)
                int siblingSum = 0;
                if (curr.left != null) siblingSum += curr.left.val;
                if (curr.right != null) siblingSum += curr.right.val;

                // Update left child value
                if (curr.left != null) {
                    curr.left.val = levelSum.get(i) - siblingSum;
                    q.offer(curr.left);
                }

                // Update right child value
                if (curr.right != null) {
                    curr.right.val = levelSum.get(i) - siblingSum;
                    q.offer(curr.right);
                }
            }
            i++;  // move to next level
        }

        return root;
    }
}



//Approach 2 - Level Order Traversal (BFS) with Level Sum Tracking
//T.C : O(n)
//S.C : O(n)



class Solution {
    public TreeNode replaceValueInTree(TreeNode root) {
        // If tree is empty, return null
        if (root == null) return root;

        // Queue for level order traversal (BFS)
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        // Initial level sum (root level)
        int levelSum = root.val;

        // Traverse tree level by level
        while (!q.isEmpty()) {
            int n = q.size();          // Number of nodes at current level
            int nextLeveSum = 0;       // Sum of values of next level nodes

            while (n-- > 0) {
                TreeNode curr = q.poll();

                // Replace current node value with (level sum - its own value)
                curr.val = levelSum - curr.val;

                // Calculate sum of its children (siblings)
                int siblingSum = curr.left != null ? curr.left.val : 0;
                siblingSum += curr.right != null ? curr.right.val : 0;

                // Process left child
                if (curr.left != null) {
                    nextLeveSum += curr.left.val;  // Add original value to next level sum
                    curr.left.val = siblingSum;    // Temporarily store sibling sum
                    q.offer(curr.left);
                }

                // Process right child
                if (curr.right != null) {
                    nextLeveSum += curr.right.val; // Add original value to next level sum
                    curr.right.val = siblingSum;   // Temporarily store sibling sum
                    q.offer(curr.right);
                }
            }

            // Move to next level
            levelSum = nextLeveSum;
        }

        return root;
    }
}
