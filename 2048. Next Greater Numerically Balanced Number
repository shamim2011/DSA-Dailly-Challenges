// Approach: Brute Force Check


class Solution {
    public int nextBeautifulNumber(int n) {
        int num = n + 1;  // Start checking from the next number
        while (true) {
            if (isSatis(num)) {  // If the current number is beautiful
                return num;      // Return it immediately
            }
            num++;  // Otherwise, check the next number
        }
    }

    // Helper method to check if a number is "beautiful"
    public boolean isSatis(int num) {
        // Map to count the frequency of each digit
        Map<Character, Integer> mp = new TreeMap<>();
        
        // Convert the number to string to easily iterate over digits
        String str = Integer.toString(num);
        
        // Count frequency of each digit
        for (char ch : str.toCharArray()) {
            mp.put(ch, mp.getOrDefault(ch, 0) + 1);
        }

        // Check if each digit appears exactly that many times
        for (Map.Entry<Character, Integer> entry : mp.entrySet()) {
            int key = entry.getKey() - '0';  // Convert character digit to integer
            int val = entry.getValue();      // Frequency of this digit
            if (key != val) {                // If frequency doesn't match the digit value
                return false;                // Not a beautiful number
            }
        }
        return true;  // All digits satisfied the condition
    }
}



//Approach-1 (Doing simulation)
//T.C : O(L-n), where L = 1224444
//S.C : O(1)

class Solution {

    // Method to find the next beautiful number greater than n
    public int nextBeautifulNumber(int n) {
        int num = n + 1; // Start checking from the next number
        while (true) {
            // If the current number satisfies the beautiful number condition, return it
            if (isSatis(num)) {
                return num;
            }
            // Otherwise, check the next number
            num++;
        }
    }

    // Helper method to check if a number is "beautiful"
    // A number is beautiful if every digit appears exactly 'digit' times.
    public boolean isSatis(int num) {
        int[] arr = new int[10]; // Frequency array to store count of each digit (0â€“9)

        // Count frequency of each digit
        while (num > 0) {
            int digit = num % 10; // Extract last digit
            arr[digit]++;         // Increment frequency of that digit
            num /= 10;            // Remove last digit
        }

        // Verify the condition for a "beautiful" number
        for (int d = 0; d <= 9; d++) {
            // If digit appears and its frequency is not equal to the digit itself, it's not beautiful
            if (arr[d] != 0 && arr[d] != d) {
                return false;
            }
        }

        // All digits satisfy the condition
        return true;
    }
}


//Approach-2 (Binary search on preciomputed list of balanced numbers)
//T.C : O(1)
//S.C : O(1)

class Solution {
    public int nextBeautifulNumber(int n) {
        int[] balancedList = {
            1, 22, 122, 212, 221, 333, 1333, 3133, 3313,
            3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323,
            32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
            122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223,
            133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333,
            223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133,
            232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321,
            242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223,
            313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331,
            323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232,
            331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122,
            333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424,
            442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515,
            555551, 666666, 1224444
        };

        int idx = Arrays.binarySearch(balancedList, n);
        if (idx < 0) idx = -idx - 1; 
        else idx++;
        return balancedList[idx];
    }
}


//Approach-3 (Bakctracking)
//T.C : O(9^d), d = number of digits of n
//S.C : O(1)

