// Approach 1 -  Stack + Reverse Traversal (Right Maximum Tracking)
// T.C - O(n)
// S.C - O(n) 



class Solution {
    public ListNode removeNodes(ListNode head) {

        // Base case: if list is empty or has only one node
        if (head == null || head.next == null) return head;

        // Stack to store all node values
        Stack<Integer> st = new Stack<>();

        // Traverse the linked list and push values into stack
        ListNode curr = head;
        while (curr != null) {
            st.push(curr.val);
            curr = curr.next;
        }

        // List to store values that should remain in final list
        List<Integer> li = new ArrayList<>();

        // Track the maximum value seen so far from the right
        int max = Integer.MIN_VALUE;

        // Process values from right to left using stack
        while (!st.isEmpty()) {
            int elem = st.pop();

            // Keep the node if it is >= max on its right
            if (elem >= max) {
                li.add(elem);
                max = Math.max(max, elem);
            }
        }

        // Dummy node to build the result list
        ListNode dummy = new ListNode(-1);
        curr = dummy;

        // Rebuild the linked list in correct order
        for (int i = li.size() - 1; i >= 0; i--) {
            curr.next = new ListNode(li.get(i));
            curr = curr.next;
        }

        // Return the final modified list
        return dummy.next;
    }
}

---------------------

class Solution {
    public ListNode removeNodes(ListNode head) {
        if(head == null || head.next == null) return head;
        Stack<Integer> st = new Stack<>();
        ListNode curr = head;
        while(curr!=null){
            st.push(curr.val);
            curr = curr.next;
        }
        ListNode dummy = new ListNode(-1);
        int max = Integer.MIN_VALUE;
        while(!st.isEmpty()){
            int elem = st.pop();
            if(elem>=max){
                ListNode newNode = new ListNode(elem);
                // Insert at front (since we are moving right → left)
                newNode.next = dummy.next;
                dummy.next = newNode;

                max = elem;
            }
        }
        
        
        return dummy.next;
    }
}


-----------------

class Solution {
    public ListNode removeNodes(ListNode head) {
        if(head == null || head.next == null) return head;
        Stack<Integer> st = new Stack<>();
        ListNode curr = head;
        while(curr!=null){
            st.push(curr.val);
            curr = curr.next;
        }
        ListNode newHead = null;
        int max = Integer.MIN_VALUE;
        while(!st.isEmpty()){
            int elem = st.pop();
            if(elem>=max){
                ListNode newNode = new ListNode(elem);
                newNode.next = newHead;   // insert at front
                newHead = newNode;       // move head
                max = elem;
            }
        }
        
        
        return newHead;
    }
}




// Approach 2 -  Recursive Right-to-Left Maximum Comparison
// T.C - O(n)
// S.C - O(n) system stack



class Solution {
    public ListNode removeNodes(ListNode head) {
        
        // Base case:
        // If list is empty OR only one node is present,
        // nothing to remove → return head
        if(head == null || head.next == null) 
            return head;

        // Recursive call:
        // Process the rest of the linked list first
        ListNode nextNode = removeNodes(head.next);

        // If current node value is smaller than
        // the maximum value on the right side,
        // remove current node by skipping it
        if(head.val < nextNode.val){
            head = null;          // optional (for clarity)
            return nextNode;      // skip current node
        }

        // Otherwise keep current node
        // and attach processed next part
        head.next = nextNode;

        return head;
    }
}



// Approach 3 -  Reverse + Max Tracking Technique
// T.C - O(n)
// S.C - O(1) 


class Solution {

    // Function to reverse a linked list
    ListNode reverse(ListNode head){
        ListNode prev = null;   // Previous node (initially null)
        ListNode curr = head;   // Current node starts from head
        ListNode next = null;   // To store next node temporarily

        // Traverse the list
        while(curr != null){
            next = curr.next;   // Store next node
            curr.next = prev;   // Reverse current node's pointer
            prev = curr;        // Move prev forward
            curr = next;        // Move curr forward
        }

        // prev will be the new head after reversal
        return prev;
    }

    public ListNode removeNodes(ListNode head) {

        // Step 1: Reverse the linked list
        head = reverse(head);

        // Step 2: Traverse reversed list and keep track of maximum value
        int max = Integer.MIN_VALUE;  // To store maximum value seen so far

        ListNode prev = null;
        ListNode curr = head;

        while(curr != null){

            // If current value is >= max so far, keep the node
            if(curr.val >= max){
                max = curr.val;       // Update max
                prev = curr;          // Move prev forward
                curr = curr.next;     // Move curr forward
            }
            else{
                // If current value is smaller than max,
                // remove this node
                prev.next = curr.next;  // Skip current node
                curr = curr.next;       // Move curr forward
            }
        }

        // Step 3: Reverse again to restore original order
        return reverse(head);
    }
}

