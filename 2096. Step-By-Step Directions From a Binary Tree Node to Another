// Approach 1 : Lowest Common Ancestor (LCA) + DFS Path Tracking
//T.C : O(n) 
//S.C : O(h)


class Solution {

    // Step 1: Find Lowest Common Ancestor (LCA) of start and destination nodes
    TreeNode lowerCommonAncester(TreeNode root, int start, int end) {
        // Base case
        if (root == null) return null;

        // If current node matches either start or end, return it
        if (root.val == start || root.val == end) return root;

        // Recur for left and right subtrees
        TreeNode leftN = lowerCommonAncester(root.left, start, end);
        TreeNode rightN = lowerCommonAncester(root.right, start, end);

        // If both sides return non-null, current node is LCA
        if (leftN != null && rightN != null) return root;

        // Otherwise return the non-null child
        if (leftN != null && rightN == null) return leftN;
        if (rightN != null && leftN == null) return rightN;

        return null;
    }

    // Step 2: Find path from a given root to target node
    // 'L' -> move left, 'R' -> move right
    boolean findpath(TreeNode root, int target, StringBuilder sb) {
        if (root == null) return false;

        // Target found
        if (root.val == target) return true;

        // Explore left subtree
        sb.append('L');
        if (findpath(root.left, target, sb)) {
            return true;
        }
        sb.deleteCharAt(sb.length() - 1); // Backtrack

        // Explore right subtree
        sb.append('R');
        if (findpath(root.right, target, sb)) {
            return true;
        }
        sb.deleteCharAt(sb.length() - 1); // Backtrack

        return false;
    }

    // Step 3: Build final directions string
    public String getDirections(TreeNode root, int startValue, int destValue) {

        // Find LCA of start and destination
        TreeNode lca = lowerCommonAncester(root, startValue, destValue);

        // Paths from LCA to start and destination
        StringBuilder lcaToStart = new StringBuilder();
        StringBuilder lcaToDest = new StringBuilder();

        // Find paths
        findpath(lca, startValue, lcaToStart);
        findpath(lca, destValue, lcaToDest);

        // Convert LCA → start path into 'U'
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < lcaToStart.length(); i++) {
            sb.append('U');
        }

        // Append LCA → destination path
        sb.append(lcaToDest);

        return sb.toString();
    }
}



// Approach 2 : Without (LCA) - Root-to-Node Path + Lowest Common Ancestor (LCA) using String Backtracking
//T.C : O(n) 
//S.C : O(h)


class Solution {

    // Helper function to find path from root to target node
    // 'L' -> move left, 'R' -> move right
    boolean findpath(TreeNode root, int target, StringBuilder sb) {

        // Base case: reached null node
        if (root == null) return false;

        // Target node found
        if (root.val == target) return true;

        // Try going to left child
        sb.append('L');
        if (findpath(root.left, target, sb)) {
            return true;
        }
        // Backtrack if left path fails
        sb.deleteCharAt(sb.length() - 1);

        // Try going to right child
        sb.append('R');
        if (findpath(root.right, target, sb)) {
            return true;
        }
        // Backtrack if right path fails
        sb.deleteCharAt(sb.length() - 1);

        // Target not found in this subtree
        return false;
    }

    public String getDirections(TreeNode root, int startValue, int destValue) {

        // Stores path from root to start node
        StringBuilder rootToStart = new StringBuilder();

        // Stores path from root to destination node
        StringBuilder rootToDest = new StringBuilder();

        // Find both paths
        findpath(root, startValue, rootToStart);
        findpath(root, destValue, rootToDest);

        // Find Lowest Common Ancestor (LCA) by removing common prefix
        int l = 0;
        while (l < rootToStart.length() &&
               l < rootToDest.length() &&
               rootToStart.charAt(l) == rootToDest.charAt(l)) {
            l++;
        }

        StringBuilder sb = new StringBuilder();

        // Move up from start node to LCA
        for (int i = 0; i < rootToStart.length() - l; i++) {
            sb.append('U');
        }

        // Move down from LCA to destination node
        for (int i = l; i < rootToDest.length(); i++) {
            sb.append(rootToDest.charAt(i));
        }

        return sb.toString();
    }
}
