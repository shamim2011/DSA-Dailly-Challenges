// Approach - 1 Brute Force with Substring Collection
// T.C - O(n)
// S.C - O(n)

import java.util.*;

class Solution {
    public String largestGoodInteger(String num) {
        // Step 1: Store all "good integers" (triplets of same digit) in a list
        List<String> li = new ArrayList<>();
        
        // Step 2: Iterate from index 2 to end (so we can check i-1 and i-2 safely)
        for (int i = 2; i < num.length(); i++) {
            // Check if current char, previous char, and char before that are same
            if (num.charAt(i) == num.charAt(i - 1) && num.charAt(i) == num.charAt(i - 2)) {
                // Extract the triplet substring and add to list
                li.add(num.substring(i - 2, i + 1));
            }
        }
        
        // Step 3: If no triplets found, return empty string
        String ans = "";
        if (li.isEmpty()) {
            return ans;
        }
        
        // Step 4: If only one triplet, return it directly
        if (li.size() == 1) {
            return li.get(0);
        }
        else {
            // Step 5: Otherwise, find the largest triplet by comparing first character (digit)
            ans = li.get(0);
            int elem = li.get(0).charAt(0); // store ASCII value of first digit of first triplet
            
            for (int i = 1; i < li.size(); i++) {
                int elem2 = li.get(i).charAt(0); // ASCII value of first digit of current triplet
                if (elem2 > elem) {
                    ans = li.get(i); // update largest triplet
                    elem = elem2;    // also update max digit tracker
                }
            }
        }
        
        // Step 6: Return the largest good integer found
        return ans;
    }
}



// Approach - 2 Sliding Window of Size 3
// T.C - O(n)
// S.C - O(1)


class Solution {
    public String largestGoodInteger(String num) {
        // Variable to store the largest "good" integer found
        String ans = "";

        // Start from index 2 so that we can check i, i-1, and i-2 together
        for (int i = 2; i < num.length(); i++) {

            // Check if the current 3 consecutive digits are equal
            if (num.charAt(i) == num.charAt(i - 1) && num.charAt(i) == num.charAt(i - 2)) {

                // Extract the substring of these 3 equal digits
                String triplet = num.substring(i - 2, i + 1);

                // Update ans if:
                // 1. ans is empty (first good integer found), or
                // 2. The digit of the new triplet is larger than the digit in ans
                if (ans.isEmpty() || triplet.charAt(0) > ans.charAt(0)) {
                    ans = triplet;
                }
            }
        }

        // Return the largest good integer found, or empty string if none
        return ans;
    }
}
