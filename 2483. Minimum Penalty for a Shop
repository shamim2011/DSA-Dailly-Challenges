//Approach-1 : Brute Force / Simulation Approach  - TLE
// T.C - O(n^2)
// S.C - O(1)



class Solution {
    public int bestClosingTime(String customers) {

        // To store the minimum penalty found so far
        int minPenalty = Integer.MAX_VALUE;

        // To store the hour at which minimum penalty occurs
        int minHour = Integer.MAX_VALUE;

        // Total number of hours
        int n = customers.length();

        // Try closing the shop at every hour from 0 to n-1
        for(int i = 0; i < n; i++){

            // Pointer to check hours before closing
            int j = i - 1;

            // Penalty for current closing hour
            int penalty = 0;

            // Count penalty for 'N' when shop was open
            // (Shop open from 0 to i-1)
            while(j >= 0){
                if(customers.charAt(j) == 'N'){
                    penalty++;
                }
                j--;
            }

            // Reset pointer to check hours after closing
            j = i;

            // Count penalty for 'Y' when shop was closed
            // (Shop closed from i to n-1)
            while(j < n){
                if(customers.charAt(j) == 'Y'){
                    penalty++;
                }
                j++;
            }

            // Update minimum penalty and corresponding hour
            if(minPenalty > penalty){
                minPenalty = penalty;
                minHour = i;
            }
        }

        // Special case: shop closes after the last hour (hour = n)
        int nthHourPenalty = 0;

        // Count penalty when shop is open for all hours
        // (Penalty only comes from 'N')
        for(int i = 0; i < n; i++){
            if(customers.charAt(i) == 'N'){
                nthHourPenalty++;
            }
        }

        // Compare penalty of closing at hour n
        if(nthHourPenalty < minPenalty){
            minPenalty = nthHourPenalty;
            minHour = n;
        }

        // Return the hour with minimum penalty
        return minHour;
    }
}



//Approach-2 Prefix Sum + Suffix Sum (Penalty Minimization)
//Note that for any index i we close at that time, we want to know 
//--how many 'N' were there from [0, i-1]
//--how many 'Y' were there from [i, n-1]
//T.C : O(n)
//S.C : O(n)

class Solution {
    public int bestClosingTime(String customers) {

        // Length of the customers string
        int n = customers.length();

        // prefix_N[i] = number of 'N' from index 0 to i-1
        int[] prefix_N = new int[n + 1];

        // suffix_Y[i] = number of 'Y' from index i to n-1
        int[] suffix_Y = new int[n + 1];

        // Base case for prefix array
        prefix_N[0] = 0;

        // Build prefix_N array
        for (int i = 1; i <= n; i++) {
            if (customers.charAt(i - 1) == 'N') {
                prefix_N[i] = prefix_N[i - 1] + 1;
            } else {
                prefix_N[i] = prefix_N[i - 1];
            }
        }

        // Build suffix_Y array
        for (int i = n - 1; i >= 0; i--) {
            if (customers.charAt(i) == 'Y') {
                suffix_Y[i] = suffix_Y[i + 1] + 1;
            } else {
                suffix_Y[i] = suffix_Y[i + 1];
            }
        }

        // Variables to track minimum penalty and best hour
        int minPenalty = Integer.MAX_VALUE;
        int minHour = Integer.MAX_VALUE;

        // Try closing the shop at every hour from 0 to n
        for (int i = 0; i <= n; i++) {

            // Penalty if closed at hour i
            int currPenalty = prefix_N[i] + suffix_Y[i];

            // Update minimum penalty and hour
            if (currPenalty < minPenalty) {
                minPenalty = currPenalty;
                minHour = i;
            }
        }

        // Return the hour with minimum penalty
        return minHour;
    }
}



//Approach-3 - 2 Pass Solution
//(T.C : O(n)
//S.C : O(1)
