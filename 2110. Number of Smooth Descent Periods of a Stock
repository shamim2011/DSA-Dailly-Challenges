// Approach - Two Pointers / Sliding Window (Greedy)
// T.C - O(n)
// S.C - O(1)


class Solution {
    public long getDescentPeriods(int[] prices) {
        int i=0;
        int j=1;
        long ans=1;
        while(j<prices.length){
            if( prices[j-1]-prices[j]==1){
			//It means that j(current element) can be part of previous subarrays (j-i) 
			//and can also start a subarray from me (+1). So add (j-i+1) in total Subarrays
                int count=j-i+1;
                ans+=count;
            }else{
			//It means that j cannot be part of previous subarrays but can start subarray from me. So, ans+=1
                i=j;
                ans+=1;
            }
            j++;
        }
        return ans;
    }
}



// Approach - Two Pointers / Sliding Window (Greedy)
// T.C - O(n)
// S.C - O(1)


class Solution {
    public long getDescentPeriods(int[] prices) {
        int n = prices.length;   // Total number of days (prices)
        
        long ans = 1;            // First element itself forms one descent period
        long count = 1;          // Length of current smooth descent sequence
        
        // Start from the second element
        for (int i = 1; i < n; i++) {
            
            // Check if current price is exactly 1 less than previous price
            if (prices[i - 1] - prices[i] == 1) {
                count++;         // Extend the descent sequence
            } else {
                count = 1;       // Reset count if descent breaks
            }
            
            // Add number of descent periods ending at index i
            ans += count;
        }
        
        return ans;              // Total smooth descent periods
    }
}
