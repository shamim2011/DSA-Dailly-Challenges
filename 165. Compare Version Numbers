// Approach - Tokenization + Comparison
// T.C - O(L1+L2)        -->  L1 = m, L2 = n
// S.C - O(L1+L2)


class Solution {
    // Approach: Tokenization + Comparison
    // 1. Split both version strings by "."
    // 2. Compare each token (converted to integer) one by one
    // 3. If one version has fewer tokens, treat missing tokens as 0
    // 4. Return 1 if version1 > version2, -1 if version1 < version2, else 0

    public int compareVersion(String version1, String version2) {
        // Step 1: Break both version strings into tokens
        List<String> li1 = getToken(version1);
        List<String> li2 = getToken(version2);

        int m = li1.size();
        int n = li2.size();

        int i = 0;
        // Step 2: Compare tokens until both lists are fully traversed
        while (i < m || i < n) {
            // If tokens exist, parse them; otherwise, take 0
            int a = i < m ? Integer.parseInt(li1.get(i)) : 0;
            int b = i < n ? Integer.parseInt(li2.get(i)) : 0;

            // Step 3: Compare integer values of tokens
            if (a > b) {
                return 1;   // version1 is greater
            } else if (b > a) {
                return -1;  // version2 is greater
            } else {
                i++;        // move to next token
            }
        }
        return 0; // All tokens are equal
    }

    // Utility method: Split version string by "." into tokens
    public List<String> getToken(String version) {
        // Regex: "\\." because "." alone means "any character" in regex
        String[] arr = version.split("\\.");
        List<String> list = new ArrayList<>();
        for (String s : arr) {
            list.add(s);
        }
        return list;
    }
}
