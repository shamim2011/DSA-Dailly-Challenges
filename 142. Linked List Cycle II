// Approach 1 - Hashing (Using HashSet to detect cycle)
// T.C - O(n)
// S.C - O(n)


public class Solution {
    public ListNode detectCycle(ListNode head) {
        
        // Create a HashSet to store visited nodes
        // If we see a node again, it means a cycle exists
        Set<ListNode> st = new HashSet<>();
        
        // Start traversing from head
        ListNode curr = head;
        
        // Traverse the linked list
        while(curr != null){
            
            // If current node is not already visited
            if(!st.contains(curr)){
                
                // Add current node into the HashSet
                st.add(curr);
                
                // Move to next node
                curr = curr.next;
            }
            else{
                // If node already exists in HashSet
                // It means cycle detected
                // Return the node where cycle begins
                return curr;
            }
        }
        
        // If traversal completes without repetition
        // No cycle exists
        return null;
    }
}


// Approach 2 - Floydâ€™s Cycle Detection Algorithm
// T.C - O(n)
// S.C - O(1)


public class Solution {

    public ListNode detectCycle(ListNode head) {
        
        // Edge case:
        // If list is empty or has only one node,
        // cycle is impossible.
        if (head == null || head.next == null) 
            return null;

        // Initialize two pointers
        // slow moves 1 step
        // fast moves 2 steps
        ListNode slow = head;
        ListNode fast = head;

        // Step 1: Detect whether cycle exists
        while (fast != null && fast.next != null) {
            
            fast = fast.next.next;  // Move 2 steps
            slow = slow.next;       // Move 1 step

            // If both meet, cycle exists
            if (slow == fast) {
                break;
            }
        }

        // If slow and fast did not meet,
        // no cycle exists
        if (slow != fast) 
            return null;

        // Step 2: Find the starting node of the cycle
        // Move one pointer to head
        ListNode entry = head;

        // Move both one step at a time
        // They will meet at cycle starting node
        while (slow != entry) {
            slow = slow.next;
            entry = entry.next;
        }

        // This is the node where cycle begins
        return entry;
    }
}


