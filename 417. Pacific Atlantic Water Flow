// âœ… Approach: Depth-First Search (DFS)
// ðŸ”¹ Time Complexity: O(m * n)
// ðŸ”¹ Space Complexity: O(m * n)

class Solution {
    public List<List<Integer>> pacificAtlantic(int[][] matrix) {
        // Final list to store coordinates that can reach both oceans
        List<List<Integer>> ans = new ArrayList<>();
        
        // Edge case: empty matrix
        if (matrix == null || matrix.length == 0) return ans;

        int m = matrix.length, n = matrix[0].length;

        // pacific[i][j] == 1 means cell (i,j) can reach the Pacific Ocean
        // atlantic[i][j] == 1 means cell (i,j) can reach the Atlantic Ocean
        int[][] pacific = new int[m][n];
        int[][] atlantic = new int[m][n];

        // Run DFS for all cells adjacent to Pacific (top row, left column)
        // and Atlantic (bottom row, right column)
        for (int col = 0; col < n; col++) {
            dfs(matrix, 0, col, Integer.MIN_VALUE, pacific);        // Top border (Pacific)
            dfs(matrix, m - 1, col, Integer.MIN_VALUE, atlantic);   // Bottom border (Atlantic)
        }

        for (int row = 0; row < m; row++) {
            dfs(matrix, row, 0, Integer.MIN_VALUE, pacific);        // Left border (Pacific)
            dfs(matrix, row, n - 1, Integer.MIN_VALUE, atlantic);   // Right border (Atlantic)
        }

        // Collect cells reachable by both oceans
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific[i][j] == 1 && atlantic[i][j] == 1) {
                    ans.add(Arrays.asList(i, j));
                }
            }
        }

        return ans;
    }

    // DFS function to mark reachable cells
    private void dfs(int[][] matrix, int i, int j, int prev, int[][] ocean) {
        int m = matrix.length, n = matrix[0].length;

        // Boundary checks
        if (i < 0 || j < 0 || i >= m || j >= n) return;

        // Already visited this cell for this ocean
        if (ocean[i][j] == 1) return;

        // Cannot flow uphill (current cell height < previous cell height)
        if (matrix[i][j] < prev) return;

        // Mark as reachable
        ocean[i][j] = 1;

        // Explore all 4 directions
        dfs(matrix, i + 1, j, matrix[i][j], ocean); // Down
        dfs(matrix, i - 1, j, matrix[i][j], ocean); // Up
        dfs(matrix, i, j + 1, matrix[i][j], ocean); // Right
        dfs(matrix, i, j - 1, matrix[i][j], ocean); // Left
    }
}
