// Approach-1 : Brute Force using ArrayList (Two-Pass Approach)
// T.C : O(n)
// S.C : O(n)



class Solution {
    public ListNode mergeNodes(ListNode head) {

        // Pointer to traverse the original linked list
        ListNode curr = head;

        // List to store all nodes of the linked list
        List<ListNode> li = new ArrayList<>();

        // Step 1: Store all nodes into ArrayList
        while(curr != null){
            li.add(curr);
            curr = curr.next;
        }

        // Dummy node to build the result list
        ListNode dummy = new ListNode(-1);
        ListNode temp = dummy;

        // Start from index 1 because first node is always 0 (as per problem)
        int i = 1;

        // Step 2: Traverse stored nodes and calculate sum between zeros
        while(i < li.size()){

            int sum = 0;

            // Keep adding values until we hit zero
            while(i < li.size() && li.get(i).val != 0){
                sum += li.get(i).val;
                i++;
            }

            // Create new node with calculated sum
            temp.next = new ListNode(sum);
            temp = temp.next;

            // Skip the zero node
            i++;
        }

        // Return merged list (excluding dummy node)
        return dummy.next;
    }
}


// Approach - 2 : Iterative Traversal with Running Sum (Simulation Approach)
// T.C : O(n)
// S.C : O(n)




class Solution {
    public ListNode mergeNodes(ListNode head) {
        
        // Dummy node to build the new resulting linked list
        ListNode dummy = new ListNode(-1);
        
        // temp pointer will help us build the new list
        ListNode temp = dummy;
        
        // We start from head.next because the first node is always 0
        ListNode curr = head.next;

        // Traverse the entire list
        while(curr != null){
            
            int sum = 0;  // To store sum between two zero nodes
            
            // Keep adding values until we encounter 0
            while(curr != null && curr.val != 0){
                sum += curr.val;     // Add current node value
                curr = curr.next;    // Move forward
            }
            
            // Create a new node with the computed sum
            temp.next = new ListNode(sum);
            
            // Move temp forward
            temp = temp.next;
            
            // Skip the zero node
            curr = curr.next;
        }
        
        // Return head of the newly formed list
        return dummy.next;
    }
}


// Approach - 3 : Two Pointer Approach (In-place Modification)
// T.C : O(n)
// S.C : O(1)



class Solution {
    public ListNode mergeNodes(ListNode head) {
        
        // p1 will store the position where we place the sum
        // Start from the first node after initial 0
        ListNode p1 = head.next;
        
        // p2 is used to traverse and calculate the segment sum
        ListNode p2 = p1;
        
        // Traverse until end of list
        while(p2 != null){
            
            int sum = 0;  // To store sum between two zero nodes
            
            // Calculate sum until we encounter next 0
            while(p2 != null && p2.val != 0){
                sum += p2.val;
                p2 = p2.next;
            }
            
            // Store the computed sum at p1 node
            p1.val = sum;
            
            // Move p2 one step ahead to skip the zero node
            p2 = p2.next;
            
            // Link current sum node to next segment start
            p1.next = p2;
            
            // Move p1 to next segment position
            p1 = p1.next;
        }
        
        // Return head.next because first node is always 0
        return head.next;
    }
}



// Approach - 4 : Recursive Summation Between Zero Nodes
// T.C : O(n)
// S.C : O(1)


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeNodes(ListNode head) {
        
        // Move head to the next node because the first node is always 0
        head = head.next;
        
        // Base case: if head becomes null, return null
        if(head == null){
            return head;
        }

        // Temporary pointer to traverse and calculate sum
        ListNode temp = head;
        int sum = 0;

        // Traverse until we reach the next 0 node
        while(temp != null && temp.val != 0){
            sum += temp.val;      // Add values between zeros
            temp = temp.next;    // Move forward
        }

        // Store the calculated sum in current head node
        head.val = sum;

        // Recursively process the remaining list after the zero
        head.next = mergeNodes(temp);

        // Return the modified head
        return head;
    }
}
