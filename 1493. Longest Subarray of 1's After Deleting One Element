// Approach-1 (Simple Brute Force)
// T.C : O(n^2)

class Solution {
    int n;

    // Helper method: Finds the longest subarray of 1s after skipping (removing) one element at index skip_idx
    int find(int[] nums, int skip_idx) {
        int currLength = 0; // current streak of consecutive 1s
        int maxLength = 0;  // maximum streak of consecutive 1s found so far

        // Iterate through the array
        for (int i = 0; i < n; i++) {
            // Skip the element at index skip_idx (treat it as "deleted")
            if (i == skip_idx) {
                continue;
            }

            if (nums[i] == 1) {
                // If current element is 1, increase current streak length
                currLength++;
                // Update maximum streak length
                maxLength = Math.max(currLength, maxLength);
            } else {
                // If current element is 0, reset streak length
                currLength = 0;
            }
        }
        return maxLength; // return the longest streak found
    }

    public int longestSubarray(int[] nums) {
        n = nums.length;
        int result = 0;  // stores the longest subarray length
        int zero = 0;    // count how many zeros exist in the array

        // Try removing each zero one by one
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                zero++;
                // Assume nums[i] is removed and check longest subarray
                result = Math.max(result, find(nums, i));
            }
        }

        // If there are no zeros in the array
        // then we must remove one element (as per problem condition)
        // so the result is (n - 1)
        if (zero == 0) {
            return n - 1;
        }

        return result; // return the maximum length found
    }
}


// Approach-2 (Sliding Windows)
// T.C : O(n)
// S.C - O(1)

class Solution {
    public int longestSubarray(int[] nums) {
        int n = nums.length;
        int i = 0;           // left pointer of the sliding window
        int countZero = 0;   // keeps track of zeros in the current window
        int ans = 0;         // stores the maximum length of valid subarray

        // Iterate with right pointer j
        for (int j = 0; j < n; j++) {
            // Expand the window by including nums[j]
            if (nums[j] == 0) {
                countZero++;
            }

            // If there are more than 1 zeros, shrink window from left
            while (countZero > 1) {
                if (nums[i] == 0) {
                    countZero--;
                }
                i++;  // move left pointer forward
            }

            // j - i = length of current valid window - 1 zero removed
            ans = Math.max(ans, j - i);
        }

        return ans; // longest subarray length after deleting one element
    }
}

// Approach-3 (Using Better Sliding Window)
// T.C : O(n)
// S.C - O(1)




