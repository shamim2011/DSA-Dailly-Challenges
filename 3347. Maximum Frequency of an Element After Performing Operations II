//Approach 1- Using Difference Array Technique (TLE)
//T.C : O(maxVal), maxVal = maximum element in nums + k
//S.C : O(maxVal), maxVal = maximum element in nums + k

class Solution {
    // Method to find the maximum frequency possible after at most numOperations
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // Initialize maxVal to track the maximum value in nums
        int maxVal = Integer.MIN_VALUE;
        // Find the maximum value in the input array
        for(int i = 0; i < nums.length; i++) {
            maxVal = Math.max(nums[i], maxVal);
        }
        
        // Create a difference array to track frequency changes within range [l, r]
        // Size is maxVal + 2 to accommodate boundary conditions
        int[] diff = new int[maxVal + 2];
        
        // Create a HashMap to store the frequency of each number in nums
        Map<Integer,Integer> mp = new HashMap<>();
        // Populate the frequency map and update the difference array
        for(int num : nums) {
            // Increment frequency of current number in the map
            mp.put(num, mp.getOrDefault(num, 0) + 1);
            // Calculate left boundary (l) within k distance, ensuring non-negative
            int l = Math.max(num - k, 0);
            // Calculate right boundary (r) within k distance, capped at maxVal
            int r = Math.min(num + k, maxVal);
            
            // Increment diff[l] to mark start of range
            diff[l]++;
            // Decrement diff[r+1] to mark end of range
            diff[r + 1]--;
        }

        // Initialize result to store the maximum frequency achievable
        int result = 1;
        // Iterate through all possible target values from 0 to maxVal
        for(int target = 0; target <= maxVal; target++) {
            // Compute cumulative sum for diff array to get frequency at target
            diff[target] += (target > 0 ? diff[target - 1] : 0);
            // Get the frequency of the current target value from the map
            int targetFreq = mp.getOrDefault(target, 0);

            // Calculate additional frequency needed to make numbers equal to target
            int needCount = diff[target] - targetFreq;
            // Cap the additional frequency by numOperations
            int maxPossFreq = Math.min(needCount, numOperations);
            // Update result with the maximum achievable frequency
            result = Math.max(result, targetFreq + maxPossFreq);
        }
        // Return the maximum frequency achievable
        return result;
    }
}


//Approach 2 - Using Difference Array Technique
//T.C : O(nlogn)
//S.C : O(n)

class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // Step 1: Find the maximum value in nums
        int maxVal = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            maxVal = Math.max(nums[i], maxVal);
        }

        // Step 2: TreeMap to represent a difference array
        // Keys = number values, Values = difference markers (+1 for start, -1 for end)
        TreeMap<Integer, Integer> diffmp = new TreeMap<>();

        // Step 3: Frequency map to count occurrences of each number
        Map<Integer, Integer> freq = new HashMap<>();

        // Step 4: Build frequency and difference map
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);

            // Determine the range [l, r] each number can reach after Â±k
            int l = Math.max(num - k, 0);
            int r = Math.min(num + k, maxVal);

            // Mark the start of range with +1
            diffmp.put(l, diffmp.getOrDefault(l, 0) + 1);
            // Mark the end of range (r+1) with -1
            diffmp.put(r + 1, diffmp.getOrDefault(r + 1, 0) - 1);

            // Ensure num is in map to calculate prefix sum later
            diffmp.putIfAbsent(num, diffmp.getOrDefault(num, 0));
        }

        // Step 5: Compute prefix sum over diffmp and calculate max achievable frequency
        int result = 1;
        int cumSum = 0;

        for (Map.Entry<Integer, Integer> entry : diffmp.entrySet()) {
            int target = entry.getKey();   // Current value being considered as target
            int val = entry.getValue();    // Difference update value

            cumSum += val;  // Maintain running prefix sum

            int targetFreq = freq.getOrDefault(target, 0); // Existing freq of this value

            // Number of other numbers that can be converted into this value
            int needCount = cumSum - targetFreq;

            // We can use at most 'numOperations' conversions
            int maxPossFreq = Math.min(needCount, numOperations);

            // Update maximum achievable frequency
            result = Math.max(result, targetFreq + maxPossFreq);
        }

        return result;
    }
}
