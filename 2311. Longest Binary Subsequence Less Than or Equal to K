//Approach-1 (Using Greedy)
//T.C : O(n)
//S.C : O(1)





//Approach-2 (Using Greedy)
//T.C : O(n)
//S.C : O(1)

class Solution {
    public int longestSubsequence(String s, int k) {
        int n = s.length();
        int length = 0;  
        // Represents the value of binary digits from right to left (1, 2, 4, 8, ...)   
        int powerVal = 1;

        // Traverse the string from right to left (least significant to most significant bit)
        for (int i = n - 1; i >= 0; i--) {
            // If the current character is '0', it adds no value in binary
            // So we can include it without changing the value, hence increase length
            if (s.charAt(i) == '0') {
                length++;
            }
            // If it's '1', we consider including it only if the current binary value is <= k
            else if (powerVal <= k) {
                k -= powerVal;  // Deduct the current binary value from k
                length++;       // Include this '1' in the subsequence
            }

            // Update the binary power for the next bit to the left (double it)
            // Only update if current power is still <= k to prevent overflow
            if (powerVal <= k) {
                powerVal *= 2;
            }
        }

        // Return the total length of the longest valid binary subsequence <= k
        return length;
    }
}
