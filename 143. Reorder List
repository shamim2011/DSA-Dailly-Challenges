// Approach 1 -  Stack-based Reordering (L0 → Ln → L1 → Ln-1 …)
// T.C - O(n)
// S.C - O(n)
 

class Solution {
    public void reorderList(ListNode head) {

        // Stack to store all nodes of the linked list
        Stack<ListNode> st = new Stack<>();

        // Pointer to traverse the list
        ListNode curr = head;

        // Push all nodes into the stack
        while (curr != null) {
            st.push(curr);
            curr = curr.next;
        }

        // Number of reorder operations needed (half of the list)
        int k = st.size() / 2;

        // Reset curr to the head of the list
        curr = head;

        // Reorder the list
        while (k-- > 0) {

            // Get the last node from the stack
            ListNode top = st.pop();

            // Store next node of current
            ListNode temp = curr.next;

            // Place last node after current node
            curr.next = top;

            // Connect last node to the next original node
            top.next = temp;

            // Move current pointer forward
            curr = temp;
        }

        // Terminate the list to avoid cycle
        if (curr != null)
            curr.next = null;
    }
}


// Approach 2 -  Slow–Fast Pointer + Reverse Second Half + Merge Alternately
// T.C - O(n)
// S.C - O(1)


class Solution {

    // Helper function to reverse a linked list
    ListNode reverse(ListNode head){
        ListNode prev = null;       // Will become new head after reversal
        ListNode curr = head;       // Current node for traversal
        ListNode nextNode = null;   // To store next node

        while(curr != null){
            nextNode = curr.next;   // Save next node
            curr.next = prev;       // Reverse current node's pointer
            prev = curr;            // Move prev forward
            curr = nextNode;        // Move curr forward
        }
        return prev;                // New head of reversed list
    }

    public void reorderList(ListNode head) {

        // Step 1: Find middle of the linked list using slow & fast pointers
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null){
            slow = slow.next;       // Moves 1 step
            fast = fast.next.next; // Moves 2 steps
        }

        // Step 2: Reverse second half of the list starting from slow
        ListNode rev = reverse(slow);

        // Step 3: Merge first half and reversed second half alternately
        ListNode curr = head;

        while(rev.next != null){
            ListNode temp = curr.next;     // Save next node of first half
            curr.next = rev;               // Link first half node to reversed node

            ListNode tempBack = rev.next;  // Save next node of reversed half
            rev.next = temp;               // Link reversed node to next first-half node

            // Move pointers forward
            rev = tempBack;
            curr = temp;
        }
    } 
}


// Approach 3 -  Recursive Two-Pointer Reordering
// T.C - O(n)
// S.C - O(1)



class Solution {

    // Pointer that always starts from the front of the list
    ListNode curr;

    // Recursive function to process nodes from the end
    void solve(ListNode head) {

        // Base case: if list is empty
        if (head == null) return;

        // Go to the end of the list
        solve(head.next);

        // Store next node of curr (front pointer)
        ListNode tempn = curr.next;

        // If curr has already reached the end, stop processing
        if (tempn == null) {
            return;
        }
        // If front and back pointers meet, terminate the list
        else if (head == curr) {
            head.next = null;
            return;
        }

        // Reorder links:
        // curr -> head (front connects to back)
        curr.next = head;

        // back connects to next front node
        // If tempn == head, avoid creating a cycle
        head.next = (tempn == head) ? null : tempn;

        // Move curr forward
        curr = tempn;
    }

    public void reorderList(ListNode head) {
        // Initialize front pointer
        curr = head;

        // Start recursive reordering
        solve(head);
    }
}
