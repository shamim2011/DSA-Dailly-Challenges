// Approach 1 -  Stack-based Reordering (L0 → Ln → L1 → Ln-1 …)
// T.C - O(n)
// S.C - O(n)
 

class Solution {
    public void reorderList(ListNode head) {

        // Stack to store all nodes of the linked list
        Stack<ListNode> st = new Stack<>();

        // Pointer to traverse the list
        ListNode curr = head;

        // Push all nodes into the stack
        while (curr != null) {
            st.push(curr);
            curr = curr.next;
        }

        // Number of reorder operations needed (half of the list)
        int k = st.size() / 2;

        // Reset curr to the head of the list
        curr = head;

        // Reorder the list
        while (k-- > 0) {

            // Get the last node from the stack
            ListNode top = st.pop();

            // Store next node of current
            ListNode temp = curr.next;

            // Place last node after current node
            curr.next = top;

            // Connect last node to the next original node
            top.next = temp;

            // Move current pointer forward
            curr = temp;
        }

        // Terminate the list to avoid cycle
        if (curr != null)
            curr.next = null;
    }
}


// Approach 2 -  Slow–Fast Pointer + Reverse Second Half + Merge Alternately
// T.C - O(n)
// S.C - O(1)


class Solution {

    // Helper function to reverse a linked list
    ListNode reverse(ListNode head){
        ListNode prev = null;       // Will become new head after reversal
        ListNode curr = head;       // Current node for traversal
        ListNode nextNode = null;   // To store next node

        while(curr != null){
            nextNode = curr.next;   // Save next node
            curr.next = prev;       // Reverse current node's pointer
            prev = curr;            // Move prev forward
            curr = nextNode;        // Move curr forward
        }
        return prev;                // New head of reversed list
    }

    public void reorderList(ListNode head) {

        // Step 1: Find middle of the linked list using slow & fast pointers
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null){
            slow = slow.next;       // Moves 1 step
            fast = fast.next.next; // Moves 2 steps
        }

        // Step 2: Reverse second half of the list starting from slow
        ListNode rev = reverse(slow);

        // Step 3: Merge first half and reversed second half alternately
        ListNode curr = head;

        while(rev.next != null){
            ListNode temp = curr.next;     // Save next node of first half
            curr.next = rev;               // Link first half node to reversed node

            ListNode tempBack = rev.next;  // Save next node of reversed half
            rev.next = temp;               // Link reversed node to next first-half node

            // Move pointers forward
            rev = tempBack;
            curr = temp;
        }
    }
}


// Approach 3 -  
// T.C - O(n)
// S.C - O(1)
