// Approach 1 - Brute Force DFS (Postorder Traversal for Subtree Sum & Count)
// T.C - O(n*n)
// S.C - O(h)



/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    // This variable will store the final count of nodes
    int ans = 0;

    // Main function
    public int averageOfSubtree(TreeNode root) {
        solve(root);     // Start DFS traversal
        return ans;      // Return total count
    }

    // This function checks each node
    void solve(TreeNode root) {
        // Base case
        if (root == null) return;

        int count = 0;   // Dummy variable (actual count calculated in findSum)

        // Get sum and count of subtree rooted at current node
        int[] arr = findSum(root, count);

        // Check if node value equals average of its subtree
        if (root.val == arr[0] / arr[1]) {
            ans++;
        }

        // Recursively check left and right subtrees
        solve(root.left);
        solve(root.right);
    }

    // This function returns:
    // arr[0] -> sum of subtree
    // arr[1] -> number of nodes in subtree
    int[] findSum(TreeNode root, int count) {

        // Base case
        if (root == null) return new int[]{0, 0};

        // Get sum and count from left subtree
        int[] leftSum = findSum(root.left, count);

        // Get sum and count from right subtree
        int[] rightSum = findSum(root.right, count);

        // Calculate total sum including current node
        int sum = root.val + leftSum[0] + rightSum[0];

        // Calculate total node count
        count = 1 + leftSum[1] + rightSum[1];

        // Return sum and count
        return new int[]{sum, count};
    }
}


-------------------------- Approach 1  Same code ------------------------------

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    public int averageOfSubtree(TreeNode root) {
        solve(root);
        return ans;
    }
    void solve(TreeNode root){
        if(root == null) return;
        int[] count = {0};
        int sum = findSum(root,count);
        if(root.val == sum / count[0]){
            ans++;
        }
        solve(root.left);
        solve(root.right);
    }
    int findSum(TreeNode root,int[] count){
        if(root == null) return 0;
        count[0]++;
        int leftSum = findSum(root.left,count);
        int rightSum = findSum(root.right,count);
        
        return leftSum + rightSum + root.val;
    }
}

-----------------------------------------------------  Approach 2  -----------------------------

// Approach 2 - Post-Order Traversal (Bottom-Up DFS)
// T.C - O(n)
// S.C - O(h)


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    // This will store the count of nodes
    // whose value equals the average of its subtree
    int ans = 0;

    // Main function
    public int averageOfSubtree(TreeNode root) {
        solve(root);   // Start post-order traversal
        return ans;    // Return final count
    }

    // Helper function that returns:
    // Pair<sum of subtree, count of nodes in subtree>
    Pair<Integer, Integer> solve(TreeNode root) {

        // Base case: empty tree
        if (root == null)
            return new Pair<>(0, 0);

        // Recursively get sum and count from left subtree
        Pair<Integer, Integer> left = solve(root.left);

        // Recursively get sum and count from right subtree
        Pair<Integer, Integer> right = solve(root.right);

        int leftSum = left.getKey();
        int leftCount = left.getValue();

        int rightSum = right.getKey();
        int rightCount = right.getValue();

        // Total sum of current subtree
        int totalSum = leftSum + rightSum + root.val;

        // Total number of nodes in current subtree
        int totalCount = leftCount + rightCount + 1;

        // Check if average equals the current node's value
        if (totalSum / totalCount == root.val)
            ans++;

        // Return sum and count to parent call
        return new Pair<>(totalSum, totalCount);
    }
}
