// Approach -(Using Power Four Range for Steps of Reduction to 0)
// T.C - O(Q * log(max r)), Q =  number of queries, r = right value of ranges
// S.C - O(1)

class Solution {

    // Helper function to calculate "steps" for a given range [l, r]
    long solve(int l, int r) {
        // L represents the start of the current range
        long L = 1;

        // S represents the step number (level depth in range hierarchy)
        // For example:
        //   1 → 3 → step 1
        //   4 → 15 → step 2
        long S = 1;

        // Total accumulated steps
        long steps = 0;

        // Loop until the current range [L, R] goes beyond 'r'
        while (L <= r) {
            // Compute the end of the current range
            // First range: [1, 3], Second range: [4, 15], then [16, 63], etc.
            long R = 4 * L - 1;

            // Clamp start of overlap with [l, r]
            long start = Math.max(L, (long) l);

            // Clamp end of overlap with [l, r]
            long end = Math.min(R, (long) r);

            // If there is an overlap, add its contribution
            if (start <= end) {
                // (end - start + 1) = number of elements covered in this range
                // Multiply by S (the step number for this level)
                steps += (end - start + 1) * S;
            }

            // Move to next step level
            S += 1;

            // Update L to next power block (multiply by 4)
            L = L * 4;
        }
        return steps;
    }

    // Main function to process all queries
    public long minOperations(int[][] queries) {
        long ans = 0;

        // For each query [l, r]
        for (int[] num : queries) {
            int l = num[0];
            int r = num[1];

            // Calculate total steps in the range
            long steps = solve(l, r);

            // Final answer requires (steps + 1) / 2 for each query
            ans += (steps + 1) / 2;
        }
        return ans;
    }
}
