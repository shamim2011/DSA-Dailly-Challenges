//Simple Approach 1- Keeping track of prev diff
//T.C : O(n)
//S.C : O(1)

class Solution {
    public int minNumberOperations(int[] target) {
        int n = target.length;   // Length of the target array
        int result = 0;          // To store the total minimum number of operations
        
        int curr = 0;            // Current value (target[i])
        int prev = 0;            // Previous value (target[i - 1])
        
        // Traverse through each element of the target array
        for (int i = 0; i < n; i++) {
            curr = target[i];    // Current element of the target array
            
            // If the current value is greater than the previous one,
            // it means we need (curr - prev) extra operations to reach this height.
            if (Math.abs(curr) > Math.abs(prev)) {
                result += Math.abs(curr - prev);
            }
            
            // Update the previous value for the next iteration
            prev = curr;
        }
        
        // Return the total minimum number of operations required
        return result;
    }
}


//Simple Approach 2- Difference-Based Increment Counting
//T.C : O(n)
//S.C : O(1)


class Solution {
    public int minNumberOperations(int[] target) {
        int n = target.length;

        // Initialize result with the first element value
        // because we need at least target[0] operations to make the first element.
        int result = target[0];
        
        // Traverse from the 2nd element to the last
        for (int i = 1; i < n; i++) {
            // If the current element is greater than the previous one,
            // we need extra operations equal to the difference.
            if (target[i] > target[i - 1]) {
                result += (target[i] - target[i - 1]);
            }
        }

        // Return the total minimum number of operations required
        return result;
    }
}
