//Approach-1 Depth First Search (DFS) with Backtracking
//T.C : O(n*h)
//S.C : O(h)



class Solution {

    // StringBuilder to store current path from root to current node
    StringBuilder sb = new StringBuilder();

    // Stores the smallest string found so far
    String s = "";

    public String smallestFromLeaf(TreeNode root) {
        dfs(root);          // start DFS traversal
        return s;           // return smallest string from leaf to root
    }

    void dfs(TreeNode root){
        // Base case
        if(root == null) return;

        // Append current node's character to path
        sb.append((char)('a' + root.val));

        // If current node is a leaf
        if(root.left == null && root.right == null){

            // Reverse to get leaf-to-root string
            sb.reverse();
            String rev = sb.toString();

            // Restore original order (root-to-leaf)
            sb.reverse();

            // Update answer if first string or smaller lexicographically
            if(s == "" || rev.compareTo(s) < 0){
                s = rev;
            }
        }

        // DFS on left and right child
        dfs(root.left);
        dfs(root.right);

        // Backtrack: remove last added character
        sb.deleteCharAt(sb.length() - 1);
    }
}



//Approach-2 Breadth-First Search (BFS) with String Construction
//T.C : O(n*h)
//S.C : O(h)


class Solution {

    public String smallestFromLeaf(TreeNode root) {

        // Queue for BFS traversal
        // Each element stores: (current node, string formed from leaf to this node)
        Queue<Pair<TreeNode, String>> q = new LinkedList<>();

        // Stores the lexicographically smallest string found so far
        String ans = "";

        // Start BFS from root
        // Convert root value to corresponding character and store as initial string
        q.offer(new Pair<>(root, String.valueOf((char)(root.val + 'a'))));

        while (!q.isEmpty()) {

            // Get current node and its corresponding string
            Pair<TreeNode, String> pair = q.poll();
            TreeNode curr = pair.getKey();
            String s = pair.getValue();

            // If leaf node is reached
            if (curr.left == null && curr.right == null) {

                // Update answer if:
                // 1) ans is empty OR
                // 2) current string is lexicographically smaller
                if (ans.equals("") || ans.compareTo(s) > 0) {
                    ans = s;
                }
            }

            // Move to left child
            // Prepend character because string is from leaf to root
            if (curr.left != null) {
                q.offer(new Pair<>(
                    curr.left,
                    (char)('a' + curr.left.val) + s
                ));
            }

            // Move to right child
            // Prepend character because string is from leaf to root
            if (curr.right != null) {
                q.offer(new Pair<>(
                    curr.right,
                    (char)('a' + curr.right.val) + s
                ));
            }
        }

        // Return the smallest string from leaf to root
        return ans;
    }
}

