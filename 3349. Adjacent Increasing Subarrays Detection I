// Approach - Sliding Window with Two Consecutive Checks
// Time Complexity:O(n Ã— k) where n is the length of nums
// Space Complexity: O(1) 


class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        // Iterate through all possible starting positions for the first subarray
        // We need at least 2k elements remaining from current position
        // Loop runs from i=0 to i=nums.size()-2*k (inclusive)
        for(int i = 0; i <= nums.size() - 2 * k; i++){
            // Check if both consecutive subarrays of length k are strictly increasing
            // First subarray: indices [i, i+k-1]
            // Second subarray: indices [i+k, i+2k-1]
            if(isSubArray(i, i + k, nums) && isSubArray(i + k, i + k + k, nums)){
                return true;
            }
        }
        return false;
    }
    boolean isSubArray(int s, int e, List<Integer> nums){
        // Check each adjacent pair in the subarray [s, e-1]
        // We compare nums[i-1] with nums[i] for i from s+1 to e-1
        for(int i = s + 1; i < e; i++){
            // If current element is not greater than previous, sequence is not strictly increasing
            if(nums.get(i - 1) >= nums.get(i)){
                return false;
            }
        }
        return true;
    }
}



//Approach (Loop and keep checking)
//T.C : O(n) 
//S.C : O(1)

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int currLen = 1; // current increasing sequence length
        int prevLen = 0; // previous increasing sequence length
        int n = nums.size(); // total number of elements

        for (int i = 1; i < n; i++) {
            // If current number is greater than the previous one, sequence continues
            if (nums.get(i) > nums.get(i - 1)) {
                currLen++;
            } 
            // Otherwise, reset sequence and store the previous length
            else {
                prevLen = currLen;
                currLen = 1;
            }

            // Condition 1: One long increasing subarray of length >= 2*k
            if (currLen >= 2 * k) return true;

            // Condition 2: Two consecutive increasing subarrays of length >= k
            if (Math.min(currLen, prevLen) >= k) return true;
        }

        // If no valid subarrays found
        return false;
    }
}
