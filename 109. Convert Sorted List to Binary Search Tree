// Approach - Slow & Fast Pointer (Middle Element as Root) – Divide and Conquer
//T.C : O(N log N)
//S.C : O(log N)



/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    public TreeNode sortedListToBST(ListNode head) {

        // Base case: empty list
        if (head == null) return null;

        // Base case: only one node in list
        if (head.next == null)
            return new TreeNode(head.val);

        // slow pointer will point to middle node
        // slow_prev will point to node before slow
        ListNode slow_prev = null;
        ListNode slow = head;
        ListNode fast = head;

        // Find middle of linked list using slow & fast pointers
        while (fast != null && fast.next != null) {
            slow_prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        // slow is now the middle node → root of BST
        TreeNode root = new TreeNode(slow.val);

        // Disconnect left half from middle
        slow_prev.next = null;

        // Recursively construct left subtree
        root.left = sortedListToBST(head);

        // Recursively construct right subtree
        root.right = sortedListToBST(slow.next);

        return root;
    }
}
