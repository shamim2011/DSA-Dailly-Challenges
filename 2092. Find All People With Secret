//Approach-1 (Most basic approach that can come to mind)
//T.C : ~O(M*(M+N)) where M = number of meetings and N = number of people
//S.C : O(M+N)


class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {

        // TreeMap to store meetings grouped by time (sorted by time automatically)
        // key   -> time
        // value -> list of meetings [x, y] happening at that time
        Map<Integer, List<int[]>> mp = new TreeMap<>();

        // Group meetings by their time
        for (int[] meeting : meetings) {
            int x = meeting[0], y = meeting[1], t = meeting[2];
            mp.computeIfAbsent(t, k -> new ArrayList<>())
              .add(new int[]{x, y});
        }

        // knownSecret[i] = true if person i knows the secret
        boolean[] knownSecret = new boolean[n];

        // Person 0 initially knows the secret
        knownSecret[0] = true;

        // firstPerson also learns the secret at time 0
        knownSecret[firstPerson] = true;

        // Process meetings in increasing order of time
        for (int t : mp.keySet()) {

            // Build graph for all meetings happening at the same time
            // key   -> person
            // value -> list of people they meet at this time
            Map<Integer, List<Integer>> meet = new HashMap<>();

            for (int[] meeting : mp.get(t)) {
                int x = meeting[0], y = meeting[1];
                meet.computeIfAbsent(x, k -> new ArrayList<>()).add(y);
                meet.computeIfAbsent(y, k -> new ArrayList<>()).add(x);
            }

            // Set of people who already know the secret
            // and are involved in meetings at this time
            Set<Integer> start = new HashSet<>();

            for (int[] meeting : mp.get(t)) {
                int x = meeting[0], y = meeting[1];

                // If either participant already knows the secret,
                // they can start spreading it at this time
                if (knownSecret[x]) {
                    start.add(x);
                }
                if (knownSecret[y]) {
                    start.add(y);
                }
            }

            // BFS to spread the secret within this time group
            Queue<Integer> q = new LinkedList<>(start);

            while (!q.isEmpty()) {
                int person = q.poll();

                // Spread secret to connected people in this time group
                for (int nextPerson : meet.getOrDefault(person, new ArrayList<>())) {
                    if (!knownSecret[nextPerson]) {
                        knownSecret[nextPerson] = true;
                        q.offer(nextPerson);
                    }
                }
            }
        }

        // Collect all people who know the secret
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            if (knownSecret[i]) {
                result.add(i);
            }
        }

        return result;
    }
}


