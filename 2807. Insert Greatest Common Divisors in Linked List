// Approach - 1 : Linked List Traversal with In-Place Node Insertion + Euclidean Algorithm (Subtraction Method)
// T.C - O(n Ã— log(maxValue))
// S.C - O(1)



class Solution {

    // Function to calculate GCD of two nodes' values
    ListNode gcd(ListNode prev, ListNode curr){
        int pVal = prev.val; 
        int cVal = curr.val;

        // If one value is 0, GCD is the other value
        if(pVal == 0) return new ListNode(cVal);
        if(cVal == 0) return new ListNode(pVal);

        // Using subtraction-based Euclidean algorithm
        while (pVal != cVal) {
            if(pVal > cVal) 
                pVal -= cVal;   // Reduce larger value
            else  
                cVal -= pVal;   // Reduce larger value
        }

        // When both become equal, that is GCD
        return new ListNode(pVal);
    }

    public ListNode insertGreatestCommonDivisors(ListNode head) {

        // Pointer to previous node
        ListNode prev = head;

        // Pointer to next node
        ListNode curr = head.next;

        // Traverse the linked list
        while(curr != null){

            // Store original next connection
            ListNode temp = prev.next;

            // Calculate GCD node
            ListNode gcdVal = gcd(prev, curr);

            // Insert GCD node between prev and curr
            prev.next = gcdVal;
            gcdVal.next = temp;

            // Move prev and curr forward
            prev = curr;
            curr = curr.next;
        }

        return head; // Return modified list
    }
}

---------------------------------------

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    int gcd(int a,int b){
        if(b == 0) return a;       
        return gcd(b,a%b);
    }
    public ListNode insertGreatestCommonDivisors(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode prev = head;
        ListNode curr = head.next;
        while(curr!=null){
            ListNode temp = new ListNode(gcd(prev.val,curr.val));
            prev.next = temp;
            temp.next = curr;
            prev = curr;
            curr = curr.next;
        }
        return head;
    }
}



// Approach - 2 : Recursive Backtracking on Linked List
// T.C - O(n)
// S.C - O(n) Recursion stack 


class Solution {

    // Helper function to calculate GCD using Euclidean Algorithm
    int gcd(int a, int b){
        // Base case: if second number becomes 0,
        // first number is the GCD
        if(b == 0) return a;

        // Recursive call
        return gcd(b, a % b);
    }

    public ListNode insertGreatestCommonDivisors(ListNode head) {

        // Base case:
        // If list is empty or only one node,
        // nothing to insert
        if(head == null || head.next == null) 
            return head;

        // Recursively process the remaining list
        ListNode temp = insertGreatestCommonDivisors(head.next);

        // Create a new node containing GCD of
        // current node and next node
        ListNode gcdNode = new ListNode(gcd(head.val, head.next.val));

        // Attach the processed remaining list after gcd node
        gcdNode.next = temp;

        // Insert gcd node between head and head.next
        head.next = gcdNode;

        // Return current head
        return head;
    }
}

