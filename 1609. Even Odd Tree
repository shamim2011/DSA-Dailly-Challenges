//Approach 1 - Level Order Traversal (BFS) with Parity & Order Validation
//T.C : O(n)
//S.C : O(n) for queue


class Solution {
    public boolean isEvenOddTree(TreeNode root) {

        // Queue for level order traversal (BFS)
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        // true  -> even level (0, 2, 4...)
        // false -> odd level  (1, 3, 5...)
        boolean evenL = true;

        // Traverse tree level by level
        while (!q.isEmpty()) {

            int n = q.size(); // number of nodes in current level

            // Initialize previous value depending on level
            // Even level  -> values must be strictly increasing
            // Odd level   -> values must be strictly decreasing
            int prev = evenL ? Integer.MIN_VALUE : Integer.MAX_VALUE;

            // Process all nodes of current level
            while (n-- > 0) {
                TreeNode curr = q.poll();

                // Validation rules:
                // Even level:
                //   - values must be odd
                //   - values must be strictly increasing
                // Odd level:
                //   - values must be even
                //   - values must be strictly decreasing
                if ((evenL && (curr.val % 2 == 0 || prev >= curr.val)) ||
                    (!evenL && (curr.val % 2 == 1 || prev <= curr.val))) {
                    return false;
                }

                // Update previous value
                prev = curr.val;

                // Add children for next level
                if (curr.left != null) q.offer(curr.left);
                if (curr.right != null) q.offer(curr.right);
            }

            // Switch level (even <-> odd)
            evenL = !evenL;
        }

        return true;
    }
}



----------------------------------------------------

class Solution {
    public boolean isEvenOddTree(TreeNode root) {
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        boolean evenL = true;
        while(!q.isEmpty()){
            int n = q.size();
            int prev = evenL?Integer.MIN_VALUE:Integer.MAX_VALUE;
            while(n-->0){
                TreeNode curr = q.poll();
                if((evenL && (curr.val%2==0 || prev>=curr.val))){
                    return false;
                }
                if((!evenL && (curr.val%2==1 || prev<=curr.val))) return false;
                prev = curr.val;
                if(curr.left!=null) q.offer(curr.left);
                if(curr.right!=null) q.offer(curr.right);
            }
            evenL = !evenL;
        }
        return true;
    }
}



//Approach 2 - DFS with Level Tracking (Preorder Traversal)
//T.C : O(n)
//S.C : Auxiliary Space O(n) + Recursion Space O(depth)


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    // Stores the previous value seen at each level
    List<Integer> levelPrev = new ArrayList<>();

    public boolean isEvenOddTree(TreeNode root) {
        // Start DFS from root at level 0
        return solve(root, 0);
    }

    boolean solve(TreeNode root, int level) {

        // Base case: empty node is valid
        if (root == null) return true;

        // Even level → value must be ODD
        if (level % 2 == 0 && root.val % 2 == 0) return false;

        // Odd level → value must be EVEN
        if (level % 2 != 0 && root.val % 2 != 0) return false;

        // First node at this level
        if (level >= levelPrev.size()) {
            levelPrev.add(root.val);
        } 
        else {
            // Even level → values must be strictly increasing
            if (level % 2 == 0 && root.val <= levelPrev.get(level)) return false;

            // Odd level → values must be strictly decreasing
            if (level % 2 != 0 && root.val >= levelPrev.get(level)) return false;

            // Update last value for this level
            levelPrev.set(level, root.val);
        }

        // DFS on left and right subtrees
        return solve(root.left, level + 1) &&
               solve(root.right, level + 1);
    }
}


