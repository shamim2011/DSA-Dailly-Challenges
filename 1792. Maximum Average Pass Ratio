//Approach-1 : (Chossing class with max delta/improvement everytime)
//T.C : O(extraStudents * n)
//S.C : O(n)


class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        int n = classes.length;  // Number of classes

        // ✅ Step 1: Store the initial pass ratio of each class
        double[] pr = new double[n];
        for (int i = 0; i < n; i++) {
            double ratio = (double) classes[i][0] / classes[i][1];  // passed / total
            pr[i] = ratio;
        }

        // ✅ Step 2: Distribute all extra students one by one
        while (extraStudents-- > 0) {
            double[] updatedPR = new double[n];

            // Compute the ratio if one extra student is added to each class
            for (int i = 0; i < n; i++) {
                double newRatio = (double) (classes[i][0] + 1) / (classes[i][1] + 1);
                updatedPR[i] = newRatio;
            }

            // ✅ Step 3: Find the class that gets the maximum benefit (delta increase in ratio)
            int bestClassIdx = 0;
            double bestDelta = 0.0;
            for (int i = 0; i < n; i++) {
                double delta = updatedPR[i] - pr[i];  // improvement in ratio
                if (delta > bestDelta) {
                    bestDelta = delta;
                    bestClassIdx = i;
                }
            }

            // ✅ Step 4: Assign the extra student to the best class
            pr[bestClassIdx] = updatedPR[bestClassIdx];   // update ratio
            classes[bestClassIdx][0]++;   // increment passed students
            classes[bestClassIdx][1]++;   // increment total students
        }

        // ✅ Step 5: Calculate final average pass ratio
        double result = 0.0;
        for (int i = 0; i < n; i++) {
            result += pr[i];
        }
        return result / n;   // average ratio across all classes
    }
}


//Approach-2 : (Chossing class with max delta/improvement everytime - Improving with max heap)
//T.C : O(extraStudents * log(n))
//S.C : O(n)

class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        int n = classes.length;

        // ✅ PriorityQueue to always pick the class where adding a student gives the maximum benefit (delta)
        PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[0], a[0]));

        // ✅ Pre-calculate delta (increase in pass ratio if one student is added) for each class
        for (int i = 0; i < n; i++) {
            double currPR = (double) classes[i][0] / classes[i][1]; // Current pass ratio
            double newPR = (double) (classes[i][0] + 1) / (classes[i][1] + 1); // Pass ratio after adding one student
            double delta = newPR - currPR; // Improvement in ratio
            pq.offer(new double[]{delta, i}); // Store delta and index
        }

        // ✅ Distribute extra students one by one
        while (extraStudents-- > 0) {
            // Pick the class with maximum improvement potential
            double[] curr = pq.poll();
            int idx = (int) curr[1];

            // Add the student to this class (both pass and total students increase)
            classes[idx][0]++;
            classes[idx][1]++;

            // Recalculate the new delta after adding the student
            double currPR = (double) classes[idx][0] / classes[idx][1];
            double newPR = (double) (classes[idx][0] + 1) / (classes[idx][1] + 1);
            double delta = newPR - currPR;

            // Push the updated delta back into the priority queue
            pq.offer(new double[]{delta, idx});
        }

        // ✅ Calculate final average pass ratio across all classes
        double result = 0.0;
        for (int i = 0; i < n; i++) {
            result += (double) classes[i][0] / classes[i][1];
        }

        return result / n; // Return average pass ratio
    }
}

