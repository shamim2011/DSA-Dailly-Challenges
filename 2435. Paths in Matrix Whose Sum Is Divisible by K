//Approach-1 (Recursion + Memoization : DP On Grids)
//T.C : O(m*n*k)
//S.C : O(m*n*k)


class Solution {
    int m; // total rows
    int n; // total columns
    int M = 1_000_000_007; // Modulo value for large results
    int[][][] t; // DP memo table: stores results for (row, col, sum % k)

    public int numberOfPaths(int[][] grid, int k) {
        m = grid.length;
        n = grid[0].length;
        
        // Initialize DP cache: dimensions -> m x n x k (sum remainder states)
        t = new int[m][n][k];
        
        // Start DFS from top-left cell with initial sum = 0
        return solve(0, 0, 0, grid, k);
    }

    int solve(int r, int c, int sum, int[][] grid, int k) {
        // If outside the grid boundaries
        if (r >= m || c >= n) {
            return 0;
        }

        // If we reached last cell (destination)
        if (r == m - 1 && c == n - 1) {
            // Check if total sum % k == 0 (valid path)
            return (sum + grid[r][c]) % k == 0 ? 1 : 0;
        }

        // If already computed this state â†’ return memoized result
        if (t[r][c][sum] != 0) {
            return t[r][c][sum];
        }

        // Move Down
        int down = solve(r + 1, c, (sum + grid[r][c]) % k, grid, k);
        // Move Right
        int right = solve(r, c + 1, (sum + grid[r][c]) % k, grid, k);

        // Store result in DP table and return
        return t[r][c][sum] = (down + right) % M;
    }
}



//Approach-2 (Bottom Up  : DP On Grids)
//T.C : O(m*n*k)
//S.C : O(m*n*k)

