//Approach-1 (Recursion + Memoization : DP On Grids)
//T.C : O(m*n*k)
//S.C : O(m*n*k)


class Solution {
    int m;
    int n;
    int M = 1_000_000_007; // Modulo value to avoid integer overflow
    Integer[][][] t; // DP memo: stores results for (row, col, sum_mod_k)

    public int numberOfPaths(int[][] grid, int k) {
        m = grid.length;
        n = grid[0].length;
        t = new Integer[m][n][k]; // Initialize DP table

        // Start DFS from (0,0) with initial sum = 0
        return solve(0, 0, 0, grid, k);
    }

    int solve(int r, int c, int sum, int[][] grid, int k) {
        // If we are out of grid bounds â†’ invalid path
        if (r >= m || c >= n) {
            return 0;
        }

        // If we reached the destination (bottom-right)
        // Check if final sum % k == 0
        if (r == m - 1 && c == n - 1) {
            return (sum + grid[r][c]) % k == 0 ? 1 : 0;
        }

        // If already computed, return cached result
        if (t[r][c][sum] != null) {
            return t[r][c][sum];
        }

        // Add current cell value to sum modulo k
        int newSum = (sum + grid[r][c]) % k;

        // Explore both possible moves: Down and Right
        int down = solve(r + 1, c, newSum, grid, k);
        int right = solve(r, c + 1, newSum, grid, k);

        // Store and return result with modulo to avoid overflow
        return t[r][c][sum] = (down + right) % M;
    }
}



//Approach-2 (Bottom Up  : DP On Grids)
//T.C : O(m*n*k)
//S.C : O(m*n*k)

