//Approach 1 -  Root-to-Leaf Path Encoding + Pairwise Distance Calculation(TLE)
//T.C : O(n^3)
//S.C : O(n)


class Solution {

    // Stores all leaf nodes of the tree
    List<TreeNode> leaf = new ArrayList<>();

    // Collect all leaf nodes using DFS
    void getAllLeaf(TreeNode root){
        if(root == null) return;

        // If both children are null, it's a leaf node
        if(root.left == null && root.right == null){
            leaf.add(root);
        }

        // Recur for left and right subtrees
        getAllLeaf(root.left);
        getAllLeaf(root.right);
    }

    // Finds path from root to target node
    // Stores path as 'L' and 'R' characters
    boolean pathFind(TreeNode root, TreeNode target, StringBuilder sb) {
        if (root == null) return false;

        // Target found
        if (root == target) return true;

        // Try going left
        sb.append('L');
        if (pathFind(root.left, target, sb)) {
            return true;
        }
        sb.deleteCharAt(sb.length() - 1); // Backtrack

        // Try going right
        sb.append('R');
        if (pathFind(root.right, target, sb)) {
            return true;
        }
        sb.deleteCharAt(sb.length() - 1); // Backtrack

        return false;
    }

    public int countPairs(TreeNode root, int distance) {
        int ans = 0;

        // Step 1: Get all leaf nodes
        getAllLeaf(root);

        // Step 2: Check every pair of leaf nodes
        for(int i = 0; i < leaf.size(); i++){
            for(int j = i + 1; j < leaf.size(); j++){

                // Path from root to first leaf
                StringBuilder rootToStart = new StringBuilder();
                // Path from root to second leaf
                StringBuilder rootToDest = new StringBuilder();

                pathFind(root, leaf.get(i), rootToStart);
                pathFind(root, leaf.get(j), rootToDest);

                // Find length of common prefix (LCA path)
                int l = 0;
                while(l < rootToStart.length() &&
                      l < rootToDest.length() &&
                      rootToStart.charAt(l) == rootToDest.charAt(l)) {
                    l++;
                }

                // Distance between two leaf nodes
                int dist = (rootToStart.length() - l) +
                           (rootToDest.length() - l);

                // Count good leaf pairs
                if(dist <= distance){
                    ans++;
                }
            }
        }
        return ans;
    }
}



//Approach 2 -  Graph Conversion + BFS from Each Leaf Node
//T.C : O(n^2)
//S.C : O(n)



class Solution {

    // This method converts the binary tree into an undirected graph
    // and also collects all leaf nodes
    void makeGraph(TreeNode root, TreeNode prev,
                   Map<TreeNode, List<TreeNode>> adj,
                   Set<TreeNode> leaf) {

        // Base case
        if (root == null) return;

        // If current node is a leaf, add it to leaf set
        if (root.left == null && root.right == null)
            leaf.add(root);

        // Create bidirectional edge between current node and its parent
        if (prev != null) {
            adj.computeIfAbsent(root, k -> new ArrayList<>()).add(prev);
            adj.computeIfAbsent(prev, k -> new ArrayList<>()).add(root);
        }

        // Recursive calls for left and right subtree
        makeGraph(root.left, root, adj, leaf);
        makeGraph(root.right, root, adj, leaf);
    }

    public int countPairs(TreeNode root, int distance) {

        // Adjacency list representation of tree as graph
        Map<TreeNode, List<TreeNode>> adj = new HashMap<>();

        // Set to store all leaf nodes
        Set<TreeNode> leaf = new HashSet<>();

        // Build graph and collect leaf nodes
        makeGraph(root, null, adj, leaf);

        int count = 0;

        // For every leaf node, perform BFS
        for (TreeNode leafNode : leaf) {

            Queue<TreeNode> q = new LinkedList<>();
            Set<TreeNode> visit = new HashSet<>();

            // Start BFS from current leaf
            q.offer(leafNode);
            visit.add(leafNode);

            // BFS up to given distance
            for (int level = 0; level <= distance; level++) {
                int n = q.size();

                while (n-- > 0) {
                    TreeNode curr = q.poll();

                    // If another leaf is found within distance
                    if (curr != leafNode && leaf.contains(curr)) {
                        count++;
                    }

                    // Traverse neighbors
                    for (TreeNode ngbr : adj.getOrDefault(curr, new ArrayList<>())) {
                        if (!visit.contains(ngbr)) {
                            q.offer(ngbr);
                            visit.add(ngbr);
                        }
                    }
                }
            }
        }

        // Each valid pair counted twice, so divide by 2
        return count / 2;
    }
}


//Approach 3 -  
//T.C : O(n)
//S.C : O(n)
