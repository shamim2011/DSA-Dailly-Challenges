// Approach 1 - Brute Force + Recursion (Generate All Combinations and Validate)
// T.C - O(2^2^n * n)
// S.C - O(4^n/n)


class Solution {
    
    // This list will store all valid parenthesis combinations
    List<String> ans = new ArrayList<>();
    
    // Function to check if a generated string is valid
    boolean isValid(String s){
        int count = 0;
        
        // Traverse each character of the string
        for(int i = 0; i < s.length(); i++){
            
            // If opening bracket, increase count
            if(s.charAt(i) == '('){
                count++;
            } 
            // If closing bracket, decrease count
            else{
                count--;
                
                // If count becomes negative,
                // it means more ')' than '(' → invalid
                if(count < 0) return false;
            }
        }
        
        // At the end, count must be 0 for valid parentheses
        return count == 0;
    }
    
    // Recursive function to generate all possible combinations
    void solve(String s, int n){
        
        // Base case:
        // If length becomes 2*n, check validity
        if(s.length() == 2 * n){
            if(isValid(s)){
                ans.add(s);
            }
            return;
        }
        
        // Add '(' and recurse
        solve(s + "(", n);
        
        // Add ')' and recurse
        solve(s + ")", n);
    }
    
    // Main function
    public List<String> generateParenthesis(int n) {
        solve("", n);
        return ans;
    }
}



// Approach 2 - Backtracking
// T.C - O(4ⁿ / √n)
// S.C - O(4ⁿ / √n)


class Solution {
    // List to store all valid parenthesis combinations
    List<String> ans = new ArrayList<>();

    // Recursive function to build valid parenthesis strings
    void solve(String s, int n, int open, int close) {
        
        // Base case: If the string length becomes 2*n,
        // it means we have used n '(' and n ')'
        if (s.length() == 2 * n) {
            ans.add(s);    
            return;
        }

        // If we can still add '(' (i.e., open < n)
        if (open < n) {
            s += '(';                       // Add '('
            solve(s, n, open + 1, close);   // Recur with one more open bracket
            s = s.substring(0, s.length() - 1);  // Backtrack (remove last character)
        }

        // If number of '(' is greater than ')',
        // we can safely add ')'
        if (open > close) {
            s += ')';                       // Add ')'
            solve(s, n, open, close + 1);   // Recur with one more close bracket
        }
    }

    public List<String> generateParenthesis(int n) {
        int open = 0;
        int close = 0;

        // Start recursion with empty string
        solve("", n, open, close);

        return ans;
    }
}
