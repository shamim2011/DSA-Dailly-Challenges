//Approach-1 (Using Binary Search + DFS)
// T.C - O((R×C)*log(R×C))​
// S.C - O(R×C)​



class Solution {

    // Number of rows and columns in the grid
    int ROW;
    int COL;

    // Possible 4-directional movements (down, up, right, left)
    int[][] directions = {
        {1, 0},
        {-1, 0},
        {0, 1},
        {0, -1}
    };

    // DFS to check if we can reach the last row starting from (i, j)
    boolean dfs(int[][] grid, int i, int j) {

        // Boundary check or water/visited cell
        if (i < 0 || i >= ROW || j < 0 || j >= COL || grid[i][j] == 1) {
            return false;
        }

        // If we reached the bottom row, crossing is possible
        if (i == ROW - 1) {
            return true;
        }

        // Mark current cell as visited (treat as water)
        grid[i][j] = 1;

        // Explore all 4 possible directions
        for (int[] dir : directions) {
            int new_i = i + dir[0];
            int new_j = j + dir[1];

            // If any path reaches the bottom row, return true
            if (dfs(grid, new_i, new_j)) {
                return true;
            }
        }

        // No valid path found from this cell
        return false;
    }

    // Checks if it is possible to cross the grid on a given day
    boolean canCross(int[][] cells, int day) {

        // Create grid where 0 = land, 1 = water
        int[][] grid = new int[ROW][COL];

        // Mark flooded cells up to the given day
        for (int i = 0; i <= day; i++) {
            int r = cells[i][0] - 1; // convert to 0-based index
            int c = cells[i][1] - 1;
            grid[r][c] = 1;
        }

        // Try to start DFS from every land cell in the top row
        for (int j = 0; j < COL; j++) {
            if (grid[0][j] == 0 && dfs(grid, 0, j)) {
                return true; // crossing is possible
            }
        }

        // No path from top to bottom
        return false;
    }

    // Binary search to find the latest day we can still cross
    public int latestDayToCross(int row, int col, int[][] cells) {

        ROW = row;
        COL = col;

        int l = 0;
        int r = cells.length - 1;
        int ans = 0;

        // Binary search on days
        while (l <= r) {

            int mid = l + (r - l) / 2;

            // If crossing is possible on 'mid' day
            if (canCross(cells, mid)) {
                ans = mid + 1;   // days are 1-based in result
                l = mid + 1;     // try to find a later day
            } else {
                r = mid - 1;     // try earlier days
            }
        }

        return ans;
    }
}
