// Approach 1 - Backtracking (Recursion + Constraint Checking)
// T.C - O(N!) - Read the reason above
// S.C - O(N) to store the result

class Solution {

    // Stores all valid board configurations
    List<List<String>> result = new ArrayList<>();

    // Size of the chessboard (N x N)
    int N;

    // Function to check whether placing a Queen at (row, col) is valid
    boolean isValid(List<String> board, int row, int col) {

        // 1️⃣ Check vertically upward (same column)
        for (int r = row - 1; r >= 0; r--) {
            if (board.get(r).charAt(col) == 'Q') {
                return false;   // Another queen found in same column
            }
        }

        // 2️⃣ Check left upward diagonal
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;   // Another queen found on left diagonal
            }
        }

        // 3️⃣ Check right upward diagonal
        for (int i = row - 1, j = col + 1; i >= 0 && j < N; i--, j++) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;   // Another queen found on right diagonal
            }
        }

        // Safe to place queen
        return true;
    }

    // Backtracking function to place queens row by row
    void solve(List<String> board, int row) {

        // Base case: If all queens are placed
        if (row >= N) {
            result.add(new ArrayList<>(board));  // Store deep copy of board
            return;
        }

        // Try placing queen in every column of current row
        for (int col = 0; col < N; col++) {

            // Check if placing at (row, col) is safe
            if (isValid(board, row, col)) {

                // Convert current row string to StringBuilder to modify it
                StringBuilder newRow = new StringBuilder(board.get(row));

                // Place Queen
                newRow.setCharAt(col, 'Q');
                board.set(row, newRow.toString());

                // Recurse for next row
                solve(board, row + 1);

                // Backtrack: Remove Queen
                newRow.setCharAt(col, '.');
                board.set(row, newRow.toString());
            }
        }
    }

    public List<List<String>> solveNQueens(int n) {

        N = n;

        // Edge case: If n = 0
        if (N == 0) return result;

        // Initialize empty board with '.'
        List<String> board = new ArrayList<>();

        // Example for n = 3:
        // board = {"...", "...", "..."}
        for (int i = 0; i < n; i++) {
            StringBuilder row = new StringBuilder();
            for (int j = 0; j < n; j++) {
                row.append('.');
            }
            board.add(row.toString());
        }

        // Start solving from row 0
        solve(board, 0);

        return result;
    }
}



// Approach 2 - Recursion & Backtracking
// T.C - O(N!) in worst case it explores all possible configurations
//S.C : O(N) for result and also for storing, cols, diags and antidiags

class Solution {
    // Stores the final list of all valid N-Queens configurations.
    List<List<String>> result = new ArrayList<>();
    // Sets to keep track of occupied columns, diagonals (row + col), and anti-diagonals (row - col).
    Set<Integer> cols = new HashSet<>();
    Set<Integer> diag = new HashSet<>();
    Set<Integer> antiDiag = new HashSet<>();
    // The size of the board (N).
    int N;

    /**
     * Recursive function to find all N-Queens solutions using backtracking.
     * 
     * @param board The current state of the board being built.
     * @param row   The current row being processed.
     */
    void solve(List<String> board, int row) {
        // Base case: All N queens have been placed successfully across all rows (0 to N-1).
        if (row >= N) {
            result.add(new ArrayList<>(board));
            return;
        }

        // Iterate through each column in the current row to try placing a queen.
        for (int col = 0; col < N; col++) {
            int diagCons = row + col; // Calculate the diagonal constant (same for all cells on the same diagonal).
            int antiDiagCons = row - col; // Calculate the anti-diagonal constant.

            // Check if the current position (row, col) is attacked by an existing queen.
            if (cols.contains(col) || diag.contains(diagCons) || antiDiag.contains(antiDiagCons)) {
                continue; // If attacked, move to the next column.
            }

            // Place the queen: mark the column, diagonal, and anti-diagonal as occupied.
            cols.add(col);
            diag.add(diagCons);
            antiDiag.add(antiDiagCons);
            // Update the board representation to place 'Q' in the current cell.
            StringBuilder newRow = new StringBuilder(board.get(row));
            newRow.setCharAt(col, 'Q');
            board.set(row, newRow.toString());

            // Recurse: move to the next row (row + 1).
            solve(board, row + 1);

            // Backtrack: remove the queen to explore other possibilities.
            cols.remove(col);
            diag.remove(diagCons);
            antiDiag.remove(antiDiagCons);
            // Restore the board representation to '.'
            newRow.setCharAt(col, '.');
            board.set(row, newRow.toString());
        }
    }

    /**
     * Main function to initialize the board and start the N-Queens solver.
     * 
     * @param n The size of the board and the number of queens.
     * @return A list of all distinct solutions.
     */
    public List<List<String>> solveNQueens(int n) {
        N = n;
        if (N == 0)
            return result; // If N is 0, return an empty result list.

        List<String> board = new ArrayList<>();
        // Initialize an empty board with '.' characters.
        // For n = 3, board = {"...", "...", "..."} initially
        for (int i = 0; i < n; i++) {
            StringBuilder row = new StringBuilder();
            for (int j = 0; j < n; j++) {
                row.append('.');
            }
            board.add(row.toString());
        }

        // Start the recursive solving process from the first row (row 0).
        solve(board, 0);
        return result;
    }
}
